#version 460 core
// Define a work group size. Adjust the local size as needed.
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct VisibleChunk { // 16 bytes
    uint offset;
    uint size;
    ivec2 pos; 
};

// input buffer to get chunks
layout(std430, binding = 0) buffer SpherePositionBuffer {
    uint packedSpheres[];
};
// input buffer to get chunks
layout(std430, binding = 1) buffer VisibleBuffer {
    VisibleChunk visibleChunks[];
};

// output buffer to draw spheres
layout(std430, binding = 2) buffer PositionBuffer {
    ivec3 visibleSpheres[];
};

// Atomic counter for tracking the number of draw calls
layout(binding = 3, offset = 0) uniform atomic_uint drawCounter;

void main(){
    uint index = gl_GlobalInvocationID.x;
    if (index < visibleChunks.length()){ // avoid accessing out of index
        VisibleChunk chunk = visibleChunks[index];

        uint drawIndex = atomicCounterAdd(drawCounter, chunk.size);

        // load all positions to the spherePositions
        for (uint i = 0;  i < chunk.size; i++){
            uint visibleID = drawIndex + i;
            uint packedID = chunk.offset + i;
            // get the packed position yVal(32-16) + zOffset(16-8) + xOffset(8-0)
            uint packedPos = packedSpheres[packedID];

            visibleSpheres[visibleID].x = chunk.
        }
        
        // calculate
    }
}