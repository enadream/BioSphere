#version 460 core
// Define a work group size. Adjust the local size as needed.
layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;

struct Sphere { // 16 bytes
    ivec3 pos;
    float radius;
};

// Binding point 0: SSBO with sphere data (vec4: xyz = center, w = radius)
layout(std430, binding = 0) readonly buffer VisibleSphereBuffer {
    Sphere spheres[];
};

// Output image declared as an integer image for atomic operations.
// (The texture format should be set to a 32-bit integer format, e.g. GL_R32I.)
layout(r32i, binding = 0) uniform iimage2D depthImage;

// The color image (the final output color buffer)
// Created with a format such as GL_RGBA8.
layout(rgba8, binding = 1) uniform image2D colorImage;

// uniforms
uniform mat4 u_ProjView;      // Combined view-projection matrix
uniform mat4 u_View;          // View matrix (for computing view-space depth).
uniform vec4 u_frustumPlanes[6];
uniform ivec2 u_ScreenSize;    // [width, height] in pixels
uniform float u_FocalLength;
uniform float u_Near;         // Near plane distance.
uniform float u_Far;          // Far plane distance.
uniform uint u_TotalNumOfSpheres;

bool IsSphereVisible(vec3 pos, float radius);

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= u_TotalNumOfSpheres){
        return;
    }

    // 1. Retrieve sphere data.
    Sphere targetSphere = spheres[index];

    float radiusWorld = targetSphere.radius;
    vec3 centerWorld = radiusWorld * targetSphere.pos;
    // check frustum culling
    if (!IsSphereVisible(centerWorld, radiusWorld)){
        return;
    }

    // 2. Compute the screen-space center.
    // Transform the sphere center to clip space.
    vec4 clipCenter = u_ProjView * vec4(centerWorld, 1.0);
    // Perspective divide to get normalized device coordinates (NDC).
    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;
    // Map NDC (-1 to 1) to screen coordinates.
    vec2 screenCenter = (ndcCenter.xy * 0.5 + 0.5) * u_ScreenSize;

    // 3. Compute view-space depth and projected radius.
    vec3 viewCenter = (u_View * vec4(centerWorld, 1.0)).xyz;
    // Assume the camera looks down -Z so we take depth as -viewCenter.z.
    float depth = -viewCenter.z;  // depth > 0 if in front of the camera.
    if (depth < 1.0){
        return;
    }

    // The sphere's projected radius in screen space (in pixels).
    float screenRadius = (radiusWorld * u_FocalLength) / depth;

    // 4. Determine the square region (pixel bounds) to update.
    // The square is centered at screenCenter and has a half-size = screenRadius.
    ivec2 minCoord = ivec2(floor(screenCenter - vec2(screenRadius)));
    ivec2 maxCoord = ivec2(ceil(screenCenter + vec2(screenRadius)));
    // Clamp to valid screen coordinates.
    minCoord = clamp(minCoord, ivec2(0), ivec2(u_ScreenSize.x-1, u_ScreenSize.y-1));
    maxCoord = clamp(maxCoord, ivec2(0), ivec2(u_ScreenSize.x-1, u_ScreenSize.y-1));

    // 5. Compute the paint value.
    // We want a value in [0,1] where a closer sphere (small depth) gives a lower value.
    // A simple mapping is:
    float depthValue = clamp((depth - u_Near) / (u_Far - u_Near), 0.0, 1.0);
    // Here, t is 0 for objects at u_near and 1 for objects at u_far.

    // 6. Convert the paint value to an integer via bit-level conversion.
    int depthInt = floatBitsToInt(depthValue);

    // 7. Fill the square region in the output image.
    // Use imageAtomicMin so that we only update a pixel if the new value is smaller
    // (i.e. the sphere is closer) than the existing value.
    for (int y = minCoord.y; y <= maxCoord.y; ++y) {
        for (int x = minCoord.x; x <= maxCoord.x; ++x) {
            float dist = length(vec2(x,y) - screenCenter);
            if (dist > screenRadius)
                continue;
            
            //dist = dist / screenRadius; // normalize
            float distToCenter = sqrt((screenRadius - dist)*(screenRadius + dist));
            distToCenter /= screenRadius; // normalize
            //depth -= distToCenter*radiusWorld;
            
            
            //float distToCenter = dist / screenRadius; // when screen radius is zero problem occurs
            int prevDepthInt = imageAtomicMin(depthImage, ivec2(x, y), depthInt);
            if (depthInt < prevDepthInt) {
 
                imageStore(colorImage, ivec2(x, y), vec4(distToCenter, distToCenter, distToCenter, 1.0));
            }
        }
    }
}


bool IsSphereVisible(vec3 pos, float radius){
    for (int i = 0; i < 6; i++){
        // Calculate signed distance from sphere center to the plane
        float dist = dot(pos, u_frustumPlanes[i].xyz) + u_frustumPlanes[i].w;

        // If the sphere is entirely behind the plane, it's not visible
        if (dist < -radius) {
            return false;
        }
    }

    return true;
}